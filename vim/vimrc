" JohnBro's vim configuration
" Time 12/25/2017

" Define OS type and GUI type in a global variable{{{1
if(has("win32") || has("win64") || has("win95") || has("win16"))
    let g:os_platform = "windows"
    let g:dir_plugin = $VIM.'/vimfiles/bundle'
elseif(has('unix'))
    let g:os_platform = "unix"
    let g:dir_plugin = "~/.vim/bundle"
else
    let g:os_platform = ""
endif

if has("gui_running")
    let g:os_gui = 1
else
    let g:os_gui = 0
endif
" }}}
" Windows GUI setting {{{1
if (g:os_platform=='windows' && g:os_gui)
    source $VIMRUNTIME/mswin.vimj
    source $VIMRUNTIME/delmenu.vim
    behave mswin
    winpos 50 50        " Window Position

    set    lines=30        " Line number of Window
    set    columns=100     " Column number of Window
    set    diffexpr=MyDiff()
    set    ambiwidth=double
    set    winaltkeys=no
    set    guifont=Inconsolata-dz\ for\ Powerline:h12

    function! MyDiff()
        let opt = '-a --binary '
        if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
        if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
        let arg1 = v:fname_in
        if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
        let arg2 = v:fname_new
        if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
        let arg3 = v:fname_out
        if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
        let eq = ''
        if $VIMRUNTIME =~ ' '
            if &sh =~ '\<cmd'
                let cmd = '""' . $VIMRUNTIME . '\diff"'
                let eq = '"'
            else
                let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
            endif
        else
            let cmd = $VIMRUNTIME . '\diff'
        endif
        silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
    endfunction
endif
" }}}
" Unix GUI setting {{{1
if(g:os_platform=='unix')
    if(g:os_gui)
        if filereadable("/etc/vim/gvimrc.local")
            source /etc/vim/gvimrc.local
        endif
    else
        set term=xterm-256color "colored airline
        set t_Co=256
        set t_ut=
        if filereadable("/etc/vim/vimrc.local")
            source /etc/vim/vimrc.local
        endif
    endif
endif
" }}}
" Bundle configure {{{1
" :PluginList       - 列出所有已配置的插件
" :PluginInstall    - 安装插件,追加 `!` 用以更新或使用 :PluginUpdate
" :PluginSearch foo - 搜索 foo ; 追加 `!` 清除本地缓存
" :PluginClean      - 清除未使用插件,需要确认; 追加 `!` 自动批准移除未使用插件
if isdirectory(expand(g:dir_plugin.'/Vundle.vim'))
    set nocompatible
    filetype off
    if (g:os_platform == 'windows')
        set runtimepath+=$VIM\vimfiles\bundle\Vundle.vim\
    else
        set runtimepath+=~/.vim/bundle/Vundle.vim/
    endif

    call vundle#begin(g:dir_plugin)

    Plugin 'VundleVim/Vundle.vim'
    Plugin 'kien/ctrlp.vim'
    Plugin 'rking/ag.vim'
    Plugin 'FelikZ/ctrlp-py-matcher'
    Plugin 'majutsushi/tagbar'
    Plugin 'Xuyuanp/nerdtree-git-plugin'
    Plugin 'scrooloose/nerdtree'
    Plugin 'scrooloose/nerdcommenter'
    Plugin 'godlygeek/tabular'                " Auto Align Plugin
    Plugin 'terryma/vim-multiple-cursors'
    Plugin 'ntpeters/vim-better-whitespace'
    Plugin 'liuchengxu/eleline.vim'
    Plugin 'Valloric/YouCompleteMe'
    Plugin 'JohnBro/DoxygenToolkit.vim'
    Plugin 'airblade/vim-gitgutter'
    Plugin 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
    Plugin 'junegunn/fzf.vim'
    Plugin 'justinmk/vim-sneak'
    Plugin 'tpope/vim-fugitive'
    Plugin 'vim-utils/vim-man'
    Plugin 'kshenoy/vim-signature'
    Plugin 'haya14busa/incsearch.vim'
    if (g:os_gui && g:os_platform == 'windows')
        Plugin 'Shougo/neocomplete.vim'
        Plugin 'plasticboy/vim-markdown'
        Plugin 'iamcco/mathjax-support-for-mkdp'
        Plugin 'iamcco/markdown-preview.vim'
    endif

    call vundle#end()
else
    " Install choco which is package manager in Windows
    if (g:os_platform == 'windows' && !executable('choco'))
        " In cmd console
        !@"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command "iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))" && SET "PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin"
        " In powershell console
        " !Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
    endif
    if executable('git')
        if (g:dir_plugin == 'windows')
            !git clone https://github.com/gmarik/Vundle.vim.git "D:\Program Files(x86)\Vim\vimfiles\bundle\Vundle.vim"
        else
            !git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim
        endif
    else
        echo "Please Install git first!"
    endif
endif
" }}}

" Basic Setting {{{1
filetype plugin on
filetype indent on
syntax enable
syntax on
set  nocompatible
set    expandtab
set    shiftwidth=4
set    tabstop=4
set    softtabstop=4
set    smarttab
set    number
set    rnu
set    numberwidth=5
set  nowrap
set    autoindent
set    autoread
set    autowrite
set    background=dark
set  nobackup
set    backspace=indent,eol,start
set    cindent
set    cinoptions=:0
set    cinoptions+=g0
set    clipboard+=unnamed
set    cursorline
set    completeopt=menuone,longest,preview
set    encoding=utf-8
set    langmenu=none
set    termencoding=utf-8
set    fileencoding=utf-8
set    fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1,default
set    fileformats=unix,dos
set    foldenable
set    foldmethod=marker
set    guioptions-=Trml
set    helplang=en
set    hidden
set    history=100
set    hlsearch
set    ruler
set    showcmd
set    incsearch
set    wildmenu
set    wildmode=list:longest,full
set    shortmess+=mrwx
set    smartcase
set    ignorecase
set    magic
set    mouse=a
set    mousehide
set    laststatus=2
set    lazyredraw
set  noshowmatch
set    matchtime=0
set    pumheight=15
set    scrolloff=5
set    smartindent
set    cmdheight=1
set    textwidth=180
set    updatetime=1000
set    whichwrap=h,l
set    wildignore=*.bak,*.o,*.e,*~
set    wildignore+=*/tmp/*,*.so,*.bin,*.swp,*.ctag
set    sessionoptions=buffers,globals,localoptions,curdir,tabpages,winsize,winpos,resize
set  noswapfile
set    ignorecase

" }}}
" Basic Functions {{{1
let g:proj_dir     = ".projDir" " Used for manage current project
let g:session_file = "project.vim"
let g:viminfo_file = "viminfo.vim"
let g:ctags_cmd    = 'ctags -f tags -I __THROW -I __THROWNL -I __nonnull -R --c-kinds=+p --fields=+iaS --extra=+q'
let g:current_path = getcwd()
let g:proj_path    = g:current_path.'/'.g:proj_dir

function! RunSystemCmd(Msg, Cmd)
    echo a:Msg
    call system(a:Cmd)
    echon 'done'
endfunction

func! EnterHandler()
    if filereadable(g:proj_path.'/'.g:session_file) && (argc() == 0)
        exe "source ".g:proj_path.'/'.g:session_file
    endif
    if filereadable(g:proj_path.'/'.g:viminfo_file) && (argc() == 0)
        exe "rviminfo! ".g:proj_path.'/'.g:viminfo_file
    endif
endfunction

func! LeaveHandler()
    if isdirectory(g:proj_path)
        exec "NERDTreeClose"
        exec "mksession! ".g:proj_path."/".g:session_file
        exec "wviminfo! ".g:proj_path."/".g:viminfo_file
    endif
endfunction

" Replace in VIM Normal mode.
function! NormalReplace()
    let l:word = input("Replace<".expand('<cword>')."> with:")
    :exe '%s/\<'.expand('<cword>').'\>/'.l:word.'/gc'
endfunction
" Replace in VIM Visible mode.
function! VisualReplace()
    let l:saved_reg = @"
    execute "normal! vgvy"
    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")
    let l:word = input("Replace " . l:pattern . " with:")
    :exe '%s/' . l:pattern . '/' . l:word . '/gc'
    let @" = l:saved_reg
endfunction
" }}}
" Usful mapping {{{1
let mapleader=','
let localleader="\\"
nnoremap <Space>                :
vnoremap <Space>                :
inoremap jk                     <Esc>
vnoremap hl                     <Esc>
nnoremap <leader>ev             :vsplit $MYVIMRC<cr>
nnoremap <leader>sv             :source $MYVIMRC<cr>
nnoremap <C-h>                  <C-W>h
nnoremap <C-j>                  <C-W>j
nnoremap <C-k>                  <C-W>k
nnoremap <C-l>                  <C-W>l
inoremap <C-h>                  <Esc><C-W>h
inoremap <C-j>                  <Esc><C-W>j
inoremap <C-k>                  <Esc><C-W>k
inoremap <C-l>                  <Esc><C-W>l
if (g:os_platform == 'windows')
    inoremap <C-v>              <Esc>"+gP
    vnoremap <C-c>              "+y<Esc>
    cnoremap <C-v>              <C-R>+
    nnoremap <M-j>              :resize +5<cr>
    nnoremap <M-k>              :resize -5<cr>
    nnoremap <M-h>              :vertical resize -5<cr>
    nnoremap <M-l>              :vertical resize +5<cr>
endif
nnoremap <leader>fn             :let @*=substitute(expand("%"), "/", "\\", "g")<cr>
nnoremap <leader>fp             :let @*=substitute(expand("%:p"), "/", "\\", "g")<cr>
nnoremap <silent>H              0
nnoremap <silent>L              $
nnoremap <Left>                 :bp<cr>
nnoremap <Right>                :bn<cr>
nnoremap <leader><Left>         :tabprevious<cr>
nnoremap <leader><Right>        :tabnext<cr>
nnoremap <leader><Right><Right> :tabnew %:p<cr>
nnoremap <leader><Left><Left>   :tabclose<cr>
nnoremap <leader>-              ddp
nnoremap <leader>_              ddkP
nnoremap <C-u>                  <Esc>ViwU<Esc>
inoremap <C-u>                  <Esc>ViwU<Esc>$a
nnoremap <silent><leader>pa     : set nu! rnu! paste!<cr>
nnoremap <leader>rp         : call NormalReplace()<cr>
vnoremap <leader>rp         : call VisualReplace()<cr>
nnoremap <silent><leader>=  gg=G<C-O><C-O>:w<CR>
nnoremap n                  nzz
nnoremap N                  Nzz
nnoremap G                  Gzz
nnoremap {                  {zz
nnoremap }                  }zz

vnoremap <                  <gv     " Indent  in vsual mode
vnoremap >                  >gv     " Deindent in visual mode shiftwidth

" New learnning.
nnoremap <leader>w" viw<Esc>i"<Esc>hbi"<Esc>lel
vnoremap <leader>w" iw<Esc>i"<Esc>h`<<Esc>i"<Esc>l`>l
onoremap p i(
onoremap in( :<C-u>normal! f(vi(<cr>
onoremap il( :<C-u>normal! F)vi(<cr>

" Get rid of my old mapping
inoremap <up>       <nop>
inoremap <down>     <nop>
inoremap <left>     <nop>
inoremap <right>    <nop>
nnoremap <up>       <nop>
nnoremap <down>     <nop>
noremap  <C-f>      <nop>       " <C-f> is the header of FZF
" }}}
" Autocmd for VIM events {{{1
" Restore the last position when reopen
" Specific identations
augroup identationGroup
    " Prevent duplicates on multiple .vimrc load
    autocmd!
    autocmd Filetype c              setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype cpp            setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype python         setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype php            setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype groovy         setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype javascript     setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype typescript     setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype json           setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype coffee         setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype pug            setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype sass           setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype scss           setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype styl           setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype css            setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype dockerfile     setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd FileType *.txt          setlocal spell,wrap,nonu
    autocmd FileType *.log          setlocal wrap
augroup END

augroup fileOperateGroup
    autocmd!
    autocmd InsertLeave *           if pumvisible() == 0|pclose|endif
    " Don't auto change line in blow files.
    autocmd BufReadPost *
                \ if line("'\"") > 0 && line("'\"") <= line("$") |
                \ exe "normal g'\"" |
                \ endif
    autocmd BufWritePre *.c,*.h,*.cpp,*.cxx     setlocal backup|setlocal backupext=.bak|set patchmode=.orig
    " autocmd BufEnter * silent! lcd %:p:h
    " autocmd VimLeave * silent! lcd g:current_path
augroup END

augroup projectConfigGroup
    autocmd!
    autocmd VimEnter * call EnterHandler()
    autocmd VimLeave * call LeaveHandler()
augroup END


" }}}
" Abbreviations
iabbrev @@      lujunboo@gmail.com
iabbrev ccopy   Copyright 2018 JohnBro<cr>lujunboo@gmail.com

" Plugin Settings{{{1
" Ag setting {{{2
if executable('ag') && isdirectory(expand(g:dir_plugin.'/ag.vim/'))
    function! AgSymbolBuffer()
        let s:ag_function = input("Ag symbol in buffers:")
        :exe 'AgBuffer! '.s:ag_function
    endfunction

    let s:ag_ignores = '--ignore ".git/" --ignore ".hg/" --ignore ".svn/"'  " dirs
    let s:ag_ignores .= ' --ignore "*.so" --ignore "*.o"'                   " files
    let g:ag_arg = 'ag --vimgrep --smart-case --nocolumn --nogroup --skip-vcs-ignores '.s:ag_ignores
    let g:ag_highlight=1
    let g:ag_format="%f:%l:%m"
    let g:ag_qhandler="botright copen 12"
    let g:ag_autoclose=1
    let g:ag_working_path_mode='r'

    noremap <F5>        : AgBuffer! <C-R><C-W><CR>
    nnoremap <leader>ag : call AgSymbolBuffer()<cr>
endif
" }}}
" FZF setting {{{2
if isdirectory(expand(g:dir_plugin.'/fzf/')) && isdirectory(expand(g:dir_plugin.'/fzf.vim/'))
    let g:fzf_tags_command = g:ctags_cmd
    function! AgSymbolProj()
        let s:ag_function = input("Ag symbol in project:")
        :exe 'FAg '.s:ag_function
    endfunction

    command! -bang -nargs=* FAg
                \ call fzf#vim#ag(<q-args>,
                \                 <bang>0 ? fzf#vim#with_preview('up:60%')
                \                         : fzf#vim#with_preview('right:50%:hidden', '?'),
                \                 <bang>0)

    command! -bang -nargs=? -complete=dir Files
                \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)

    noremap  <F6>       :FAg <C-R><C-W><CR>
    nnoremap <leader>aG :call AgSymbolProj()<cr>
    nnoremap <Leader>? <plug>(fzf-maps-n)
    xnoremap <Leader>? <plug>(fzf-maps-x)
    onoremap <Leader>? <plug>(fzf-maps-o)

    nnoremap <Leader>fb : Buffers<CR>
    nnoremap <leader>b? : Buffers<CR>
    nnoremap <leader>ff : exec 'Files '.g:current_path<CR>
    nnoremap <leader>f/ : Files<CR>
    nnoremap <leader>fm : Marks<CR>
    nnoremap <leader>ft : Filetypes<CR>
    nnoremap <leader>fu : Commands<CR>
    nnoremap <Leader>hf : History<CR>       " File history
    nnoremap <Leader>hc : History:<CR>      " Command histoy
    nnoremap <leader>hs : History/<CR>      " Search history
    nnoremap <C-p>      : exec 'Files '.g:current_path<CR>              " Using this <C-p> to replace Ctrlp mapping
    noremap <C-f>f      : Files<CR>
    noremap <C-f>b      : Buffers<CR>
    noremap <C-f>l      : Lines<CR>
    noremap <C-f>t      : BTags<CR>
    noremap <C-f>g      : Tags<CR>
    noremap <C-f>m      : Maps<CR>
    noremap <C-f>u      : Commands<CR>

endif
" }}}
" Ctrlp.vim settings {{{2
if isdirectory(expand(g:dir_plugin.'/ctrlp.vim/'))
    nnoremap <F4>       :CtrlPMRU<cr>
    nnoremap <leader>fr :CtrlPMRU<cr>
    let g:loaded_ctrlp=0
    let g:ctrlp_working_path_mode='ra'
    let g:ctrlp_match_window='bottom,order:btt,min:1,max:12,results:12'
    let g:ctrlp_by_filename=1
    let g:ctrlp_switch_buffer = 'et'
    let g:ctrlp_regexp = 1
    let g:ctrlp_default_input=0
    let g:ctrlp_use_caching=1
    let g:ctrlp_clear_cache_on_exit=0
    let g:ctrlp_mruf_max = 250
    let g:ctrlp_max_history=&history
    let g:ctrlp_lazy_update=1
    let g:ctrlp_map = '<c-p>'
    let g:ctrlp_cmd = 'CtrlP'
    let g:ctrlp_follow_symlinks = 1
    let g:ctrlp_mruf_relative = 1
    let g:ctrlp_mruf_execlude = '/tmp/.*\|/temp/.*'
    let g:ctrlp_cache_dir=$HOME.'/.cache/ctrlp'
    let g:ctrlp_custom_ignore = {
                \ 'dir':  '\v[\/]\.(git|hg|svn)$',
                \ 'file': '\v(\.exe|\.so|\.dll|\.bin|\.pkg|\.bak|\.\~|\.mak|Makefile|\.zip|\.tar|\.gz|\.bz2)',
                \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
                \ }
    if executable('ag')
        " Use Ag over Grep
        set grepprg=ag\ --nogroup\ --nocolor
        " Use Ag in Ctrlp for listing files
        let s:ctrlp_fallback = 'ag %s -l -g ""'
        let g:ctrlp_use_caching = 0
    elseif executable('ack-grep')
        let s:ctrlp_fallback='ack-grep %s --nogroup -f ""'
        let g:ctrlp_use_caching = 0
    elseif executable('ack')
        let s:ctrlp_fallback='ack %s --nogroup -f ""'
        let g:ctrlp_use_caching = 0
    elseif has('win32')
        let s:ctrlp_fallback='dir %s /-n /b /s /a-d'
        let g:ctrlp_use_caching = 0
    else
        if (g:os_platform == 'windows')
            let s:ctrlp_fallback = 'dir %s /-n /b /s /a-d' " Windows
        else
            let s:ctrlp_fallback = 'find %s -type f'       " MacOSX/Linux
        endif
    endif
    if exists("g:ctrlp_user_command")
        unlet g:ctrlp_user_command
    endif
    if exists("s:ctrlp_fallback")
        let g:ctrlp_user_command = {
                    \ 'types': {
                    \ 1: ['.git', 'cd %s && git ls-files . --cached --others'],
                    \ 2: ['.hg', 'hg --cwd %s locate -I .'],
                    \ },
                    \ 'fallback': s:ctrlp_fallback
                    \ }
    endif
    " Fast CtrlP matcher based on python, performance difference is up to x22
    if isdirectory(expand("~/.vim/bundle/ctrlp-py-matcher/"))
        let g:ctrlp_match_func = {'match': 'pymatcher#PyMatch'}
    endif
endif
" }}}
" Tagbar settings {{{2
if isdirectory(expand(g:dir_plugin.'/tagbar/')) && executable('ctags')
    nnoremap <F2> :TagbarToggle<cr>
    let g:tagbar_left=1
    let g:tagbar_width=30
    let g:tagbar_autoclose=1
    let g:tagbar_autofocus=1
    let g:tagbar_sort=0
    let g:tagbar_compact = 1
    let g:tagbar_indent = 1
    let g:tagbar_autopreview = 1
    let g:tagbar_foldlevel=2
    let g:tagbar_previewwin_pos="rightbelow"
endif
" }}}
" Nerdtree settings {{{2
if isdirectory(expand(g:dir_plugin.'/nerdtree/'))
    nnoremap <F3> :NERDTreeToggle<cr>
    nnoremap <leader>nf :NERDTreeFind<CR>
    let NERDTreeQuitOnOpen=1
    let NERDTreeShowLineNumbers=1
    let NERDTreeWinPos="right"
    let NERDTreeWinSize=30
    if isdirectory(expand("~/.vim/bundle/nerdtree-git-plugin"))
        let g:NERDTreeIndicatorMapCustom = {
                    \ "Modified"  : "✹",
                    \ "Staged"    : "✚",
                    \ "Untracked" : "✭",
                    \ "Renamed"   : "➜",
                    \ "Unmerged"  : "═",
                    \ "Deleted"   : "✖",
                    \ "Dirty"     : "✗",
                    \ "Clean"     : "✔︎",
                    \ 'Ignored'   : '☒',
                    \ "Unknown"   : "?"
                    \ }
    endif
endif
" }}}
" Syntastic settings {{{2
if isdirectory(expand(g:dir_plugin.'/syntastic/'))
    set    statusline+=%#warningmsg#
    set    statusline+=%{SyntasticStatuslineFlag()}
    set    statusline+=%*
    "let g:syntastic_always_populate_loc_list = 1
    "let g:syntastic_auto_loc_list = 1
    let g:syntastic_check_on_open = 1
    let g:syntastic_check_on_wq = 1
    let g:syntastic_error_symbol='>>'
    let g:syntastic_warning_symbol='>'
    let g:syntastic_enable_highlighting=1
    let g:syntastic_auto_jump=0
    "let g:syntastic_airline
    let g:syntastic_javascript_checkers = ['jsl', 'jshint']
    let g:syntastic_html_checkers=['tidy', 'jshint']

    let g:syntastic_c_check_header = 0
    let g:syntastic_c_remove_include_headers=1
    let g:syntastic_cpp_check_errors = 1
    let g:syntastic_cpp_remove_include_headers=0
    function! ToggleErrors()
        let old_last_winnr = winnr('$')
        lclose
        if old_last_winnr == winnr('$')
            " Nothing was closed, open syntastic error location panel
            Errors
        endif
    endfunction
    nnoremap <Leader>s :call ToggleErrors()<cr>
    nnoremap <Leader>sn :lnext<cr>
    nnoremap <Leader>sp :lprevious<cr>
endif
" }}}
" NERDcommenter settings {{{2
if isdirectory(expand(g:dir_plugin.'/nerdcommenter/'))
    let g:NERDSpaceDelims = 1
    let g:NERDComaptSexyComs = 1
    let g:NERDAltDelims_java = 1
    let g:NERDCommentEmptyLines = 1
    let g:NERDDefaultAlign = 'left'
    let g:NERDTrimTrailingWhitespace = 1
endif
" }}}
" Completion Plugin configuration {{{2
" Common configuration {{{3
inoremap <expr> <CR>       pumvisible() ? "\<C-y>" : "\<CR>"
inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"
inoremap <expr> <PageDown> pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<PageDown>"
inoremap <expr> <PageUp>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<PageUp>"
"}}}
" YouCompleteMe settings {{{3
" !Windows : Completer by YouCompleteMe
if (isdirectory(expand(g:dir_plugin.'/YouCompleteMe/')))
    let g:ycm_global_ycm_extra_conf               = './.vim/bundle/YouCompleteMe/.ycm_extra_conf.py'
    let g:ycm_confirm_extra_conf                  = 0
    let g:ycm_show_diagnostics_ui                 = 1
    let g:ycm_server_log_level                    = 'info'
    let g:ycm_collect_identifiers_from_tags_files = 1
    let g:ycm_min_num_of_chars_for_completion     = 2
    let g:ycm_min_num_identifier_candidate_chars  = 2
    let g:ycm_seed_identifiers_with_syntax        = 1 " Open syntax complete
    let g:ycm_complete_in_comments                = 1 " Also in comments
    let g:ycm_complete_in_strings                 = 1
    let g:ycm_cache_omnifunc                      = 0
    let g:ycm_add_preview_to_completeopt          = 0
    let g:ycm_key_invoke_completion               = '<C-z>'
    let g:ycm_semantic_triggers =  {
                \   'c' : ['->', '.', 're!\w{3}'],
                \   'objc' : ['->', '.', 're!\[[_a-zA-Z]+\w*\s', 're!^\s*[^\W\d]\w*\s',
                \             're!\[.*\]\s'],
                \   'ocaml' : ['.', '#'],
                \   'cpp,cuda,objcpp' : ['->', '.', '::', 're!\w{3}'],
                \   'perl' : ['->'],
                \   'php' : ['->', '::'],
                \   'cs,java,javascript,typescript,d,python,perl6,scala,vb,elixir,go' : ['.'],
                \   'ruby' : ['.', '::'],
                \   'lua' : ['.', ':'],
                \   'erlang' : [':'],
                \ }
    let g:ycm_filetype_blacklist                  = {
                \ 'tagbar' : 1,
                \ 'nerdtree' : 1,
                \ 'markdown' : 1,
                \ 'unite' : 1,
                \ 'text' : 1,
                \ 'vimwiki' : 1,
                \ 'pandoc' : 1,
                \ 'infolog' : 1,
                \ 'mail' : 1
                \ }
    nnoremap <C-\>] :YcmCompleter GoTo<cr>
    nnoremap <leader>ye :YcmDiags<cr>
    nnoremap <leader>yl :YcmCompleter GoToDeclaration<CR>
    nnoremap <leader>yf :YcmCompleter GoToDefinition<CR>
    nnoremap <leader>yu :YcmCompleter GoToDefinitionElseDeclaration<CR>
endif
" }}}
" Neocomplete.vim setting {{{3
if isdirectory(expand(g:dir_plugin.'/neocomplete.vim/')) && has('lua') && 0
    "disable AutoComplPop.
    let g:acp_enableAtStartup = 0
    " Use neocomplete.
    let g:neocomplete#enable_at_startup = 1
    " Use smartcase.
    let g:neocomplete#enable_smart_case = 1
    " Set minimum syntax keyword length.
    let g:neocomplete#sources#syntax#min_keyword_length = 3

    " Define dictionary.
    let g:neocomplete#sources#dictionary#dictionaries = {
                \ 'default' : '',
                \ 'vimshell' : $HOME.'/.vimshell_hist',
                \ 'scheme' : $HOME.'/.gosh_completions'
                \ }

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns['default'] = '\h\w*'

    " Plugin key-mappings.
    inoremap <expr><C-g>     neocomplete#undo_completion()
    inoremap <expr><C-l>     neocomplete#complete_common_string()

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
        return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
        " For no inserting <CR> key.
        "return pumvisible() ? "\<C-y>" : "\<CR>"
    endfunction
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
    " Close popup by <Space>.
    "inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

    " AutoComplPop like behavior.
    "let g:neocomplete#enable_auto_select = 1

    " Shell like behavior(not recommended).
    "set completeopt+=longest
    "let g:neocomplete#enable_auto_select = 1
    "let g:neocomplete#disable_auto_complete = 1
    "inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

    " Enable omni completion.
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

    " Enable heavy omni completion.
    if !exists('g:neocomplete#sources#omni#input_patterns')
        let g:neocomplete#sources#omni#input_patterns = {}
    endif
    let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

    " For perlomni.vim setting.
    " https://github.com/c9s/perlomni.vim
    let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
endif
" }}}
" }}}
" vim Markdown setting, just in gui {{{2
if isdirectory(expand(g:dir_plugin.'/markdown-preview.vim/'))
    let g:mkdp_path_to_chrome = "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"
    let g:mkdp_auto_start = 0
    let g:mkdp_auto_open = 0
    let g:mkdp_auto_close = 1
    let g:mkdp_refresh_slow = 0
    let g:mkdp_command_for_global = 0
    nnoremap <silent> <F11> <Plug>MarkdownPreview
    inoremap <silent> <F11> <Plug>MarkdownPreview
    nnoremap <leader>ms <Plug>StopMarkdownPreview
endif
"}}}
" VIM Multiple Line setting {{{2
if isdirectory(expand(g:dir_plugin.'/vim-multiple-cursors/'))
    " Default mapping
    let g:multi_cursor_use_default_mapping = 0
    let g:multi_cursor_start_word_key      = '<C-n>'
    let g:multi_cursor_select_all_word_key = '<A-n>'
    let g:multi_cursor_start_key           = 'g<C-n>'
    let g:multi_cursor_select_all_key      = 'g<A-n>'
    let g:multi_cursor_next_key            = '<C-n>'
    let g:multi_cursor_prev_key            = '<C-p>'
    let g:multi_cursor_skip_key            = '<C-x>'
    let g:multi_cursor_quit_key            = '<Esc>'
endif
"}}}
" Better white-space setting {{{2
if isdirectory(expand(g:dir_plugin.'/vim-better-whitespace/'))
    let g:better_whitespace_filetypes_blacklist=['txt', 'log', 'diff', 'unite', 'qf', 'help']
    let g:better_whitespace_verbosity = 0
    let g:better_whitespace_oprator = '<leader>wt'
    nnoremap    <leader>wr          :StripWhitespace<cr>
    nnoremap    <leader>tw          :ToggleStripWhitespaceOnSave<cr>
    autocmd     BufWritePre    *     EnableWhitespace
    autocmd     FileType    javascript,c,cpp,java,html,ruby,vimscript,shell
                \ autocmd BufEnter <buffer>     EnableWhitespace
endif
"}}}
" Ctags setting {{{2
if executable('ctags')
    let g:ctags_file = 'tags'
    let g:ctags_path = g:current_path

    function! GenerateCtags()
        if filereadable(g:ctags_path.'/'.g:ctags_file)
            echo "Ctags file already exists!"
            setglobal tags+=tags
        else
            call RunSystemCmd('Start to generate Ctags...', g:ctags_cmd)
        endif
        if !isdirectory(g:proj_path)
            call RunSystemCmd('Create project directory...', 'mkdir '.g:proj_path)
        endif
    endfunction

    if isdirectory(g:ctags_path.'/'.g:proj_dir) && !filereadable(g:ctags_path.'/'.g:ctags_file)
        call GenerateCtags()
    endif
    autocmd BufReadPre *.c,*.h,*.cpp,*.cxx  set tags+=tags;
    nnoremap <F9>        : call GenerateCtags()<cr>
    nnoremap <leader>gct : call GenerateCtags()<cr>
endif
" }}}
" Cscope setting {{{2
if has('cscope') && executable('cscope')
    set cscopetag
    set csto=0
    " Show message when any oterhs cscope db added
    " set cscopeverbose
    let g:cscope_file = 'cscope.out'
    let g:cscope_path = g:proj_path
    function! EstablishCscope()
        if !isdirectory(g:cscope_path)
            call RunSystemCmd('Create project directory...', 'mkdir '.g:cscope_path)
        endif
        if filereadable(g:cscope_path.'/'.g:cscope_file)
            echo "Cscope file already exist!"
            exe 'cscope add '.g:cscope_path.'/'.g:cscope_file
        elseif $CSCOPE_DB != ""
            cscope add $CSCOPE_DB
        else
            call RunSystemCmd('Generate cscope...', 'cscope -Rbq -f '.g:cscope_path.'/'.g:cscope_file)
            exe 'cscope add '.g:cscope_path.'/'.g:cscope_file
        endif
        if !isdirectory(g:proj_path)
            call RunSystemCmd('Create project directory...', 'mkdir '.g:proj_path)
        endif
    endfunction

    autocmd BufReadPost *.c,*.h,*.cpp,*.cxx
                \ if isdirectory(g:cscope_path) |
                \     if filereadable(g:cscope_path.'/'.g:cscope_file) |
                \         exe 'cscope add '.g:cscope_path.'/'.g:cscope_file |
                \     elseif $CSCOPE_DB != "" |
                \         cscope add $CSCOPE_DB |                \     endif |
                \ endif

    " <F10> To establish a cscope enviroment.
    nnoremap <leader>gcs    : call EstablishCscope()<cr>
    nnoremap <F10>          : call EstablishCscope()<cr>
    nnoremap <C-\>a         : cscope add cscope.out<cr>
    nnoremap <C-\>s         :cs find s <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-\>g         :cs find g <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-\>c         :cs find c <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-\>t         :cs find t <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-\>e         :cs find e <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-\>f         :cs find f <C-R>=expand("<cfile>")<CR><CR>
    nnoremap <C-\>i         :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nnoremap <C-\>d         :cs find d <C-R>=expand("<cword>")<CR><CR>
endif
"}}}
" Vim-Gitgutter setting {{{2
if isdirectory(expand(g:dir_plugin.'/vim-gitgutter/'))
    let g:gitgutter_map_keys = 0
    let g:gitgutter_highlight_lines = 0
    let g:gitgutter_max_signs = 5000
    nmap [h <Plug>GitGutterPrevHunk
    nmap ]h <Plug>GitGutterNextHunk
    nnoremap <leader>tg :GitGutterLineHighlightsToggle<cr>
    nnoremap <leader>gp :GitGutterPreviewHunk<cr>
    nnoremap <leader>gs :GitGutterStageHunk<cr>
    nnoremap <leader>gu :GitGutterUndoHunk<cr>
endif
" }}}
" DoxygenToolkit.vim setting {{{2
if isdirectory(expand(g:dir_plugin.'/DoxygenToolkit.vim/'))
    let g:doxygen_enhanced_color      = 1
    let g:DoxygenToolkit_commentType  = "C"
    let g:DoxygenToolkit_funcName     = "yes"
    let g:DoxygenToolkit_dataTag      = "@data    "
    let g:DoxygenToolkit_briefTag_pre = "@fn      "
    let g:DoxygenToolkit_briefTag_pre = "@brief   "
    let g:DoxygenToolkit_paramTag_pre = "@param[] "
    let g:DoxygenToolkit_returnTag    = "@retval  "
    let g:DoxygenToolkit_versionTag   = "@version "
    let g:DoxygenToolkit_authorName   = "JohnBro lujunboo@gmail.com"
    let g:DoxygenToolkit_blockHeader  = "----------------------------------------------------------------------------"
    let g:DoxygenToolkit_blockFooter  = "----------------------------------------------------------------------------"

    nnoremap <leader>df :Dox<cr>
    nnoremap <leader>db :DoxBlock<cr>
    nnoremap <leader>da :DoxAuthor<cr>
    nnoremap <leader>dl :DoxLic<cr>
endif
" }}}
" Tabularize setting {{{2
if isdirectory(expand(g:dir_plugin.'/tabular/'))
    function! TabularAlign()
        let l:align_symbol = input("What's symbol do you align to:")
        :exe 'Tabularize /'.l:align_symbol
    endfunction

    vnoremap <leader>al : call TabularAlign()<cr>
    nnoremap <leader>al : call TabularAlign()<cr>
endif
"}}}
" Easymotion setting {{{2
" Default key bindings
" <Leader><Leader>jw : word
" <Leader><Leader>jb : back
" <Leader><Leader>jh : back in line
" <Leader><Leader>jj : next line
" <Leader><Leader>jk : back line
" <Leader><Leader>jl : next in line
if isdirectory(expand(g:dir_plugin.'/vim-easymotion/'))
    noremap <Leader><Leader> <Plug>(easymotion-prefix)
    noremap <Leader><Leader>jh <Plug>(easymotion-linebackward)
    noremap <Leader><Leader>jj <Plug>(easymotion-j)
    noremap <Leader><Leader>jk <Plug>(easymotion-k)
    noremap <Leader><Leader>jl <Plug>(easymotion-lineforward)
    " 重复上一次操作, 类似repeat插件, 很强大
    noremap <Leader><Leader>j. <Plug>(easymotion-repeat)
endif
" }}}
" vim-fugitive setting {{{2
if isdirectory(expand(g:dir_plugin.'/vim-fugitive/'))
endif
" }}}
"}}}
