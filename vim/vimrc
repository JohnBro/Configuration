" JohnBro's vim configuration
" Time 12/25/2017

" Define OS type and GUI type in a global variable{{{1
if(has("win32") || has("win64") || has("win95") || has("win16"))
    let g:os_platform = "windows"
    let g:dir_plugin = $VIM.'/vimfiles/plugins'
elseif(has('Unix'))
    let g:os_platform = "unix"
    let g:dir_plugin = "~/.vim/plugins"
else
    let g:os_platform = ""
endif

if has("gui_running")
    let g:os_gui = 1
else
    let g:os_gui = 0
endif
" }}}
" Windows GUI setting {{{1
if (g:os_platform=='windows' && g:os_gui)
    source $VIMRUNTIME/mswin.vimj
    source $VIMRUNTIME/delmenu.vim
    behave mswin
    winpos 50 50        " Window Position

    set    lines=30        " Line number of Window
    set    columns=100     " Column number of Window
    set    diffexpr=MyDiff()
    set    ambiwidth=double
    set    winaltkeys=no
    set    guifont=Inconsolata-dz\ for\ Powerline:h12

    function! MyDiff()
        let opt = '-a --binary '
        if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
        if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
        let arg1 = v:fname_in
        if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
        let arg2 = v:fname_new
        if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
        let arg3 = v:fname_out
        if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
        let eq = ''
        if $VIMRUNTIME =~ ' '
            if &sh =~ '\<cmd'
                let cmd = '""' . $VIMRUNTIME . '\diff"'
                let eq = '"'
            else
                let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
            endif
        else
            let cmd = $VIMRUNTIME . '\diff'
        endif
        silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
    endfunction
endif
" }}}
" Unix GUI setting {{{1
if(g:os_platform=='unix')
    if(g:os_gui)
        if filereadable("/etc/vim/gvimrc.local")
            source /etc/vim/gvimrc.local
        endif
    else
        set term=xterm-256color "colored airline
        set t_Co=256
        set t_ut=
        if filereadable("/etc/vim/vimrc.local")
            source /etc/vim/vimrc.local
        endif
    endif
endif
" }}}
" Vim plugin manager setting {{{1
let $VIM_PLUGDIR = expand(g:dir_plugin.'/vim-plug')
if empty(glob(expand($VIM_PLUGDIR."/plug.vim")))
    silent !curl -fLo $VIM_PLUGDIR/plug.vim --create-dirs
                \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source ~/.vimrc
endif

if isdirectory(expand(g:dir_plugin.'/vim-plug/'))

    set nocompatible
    source $VIM_PLUGDIR/plug.vim

    call plug#begin(g:dir_plugin)

    Plug 'hecal3/vim-leader-guide'
    Plug 'rking/ag.vim'
    Plug 'kien/ctrlp.vim',                  { 'on': [ 'CtrlP', 'CtrlPMRU' ] }
    Plug 'FelikZ/ctrlp-py-matcher',         { 'on': [ 'CtrlP', 'CtrlPMRU' ] }
    Plug 'majutsushi/tagbar'
    Plug 'scrooloose/nerdtree',             { 'on': [ 'NERDTreeToggle', 'NERDTreeFind' ] }
    Plug 'Xuyuanp/nerdtree-git-plugin',     { 'on': [ 'NERDTreeToogle', 'NERDTreeFind' ] }
    Plug 'danro/rename.vim',                { 'on': 'Rename' }
    Plug 'scrooloose/nerdcommenter',        { 'on': '<Plug>NERDCommenterToggle' }
    Plug 'godlygeek/tabular',               { 'on': 'Tabularize' }
    Plug 'junegunn/vim-easy-align',         { 'on': [ '<Plug>(EasyAlign)', 'EasyAlign' ] }
    Plug 'terryma/vim-multiple-cursors'
    Plug 'ntpeters/vim-better-whitespace',  { 'for': [ 'c', 'cpp', 'Makefile' ] }
    Plug 'liuchengxu/eleline.vim'
    Plug 'Valloric/YouCompleteMe'
    Plug 'rdnetto/YCM-Generator',           { 'on': ['YcmGenerateConfig', 'CCGenerateConfig'], 'branch': 'stable' }
    Plug 'JohnBro/DoxygenToolkit.vim'
    Plug 'JohnBro/Mark'
    Plug 'JohnBro/dictionary.vim'
    Plug 'junegunn/fzf', { 'do': './install --all' }
    Plug 'junegunn/fzf.vim'
    Plug 'justinmk/vim-sneak'
    Plug 'airblade/vim-gitgutter'
    Plug 'tpope/vim-fugitive'
    Plug 'vim-utils/vim-man',               { 'for': [ 'c', 'cpp' ] }
    Plug 'ludovicchabant/vim-gutentags',    { 'for': [ 'c', 'cpp' ] }
    Plug 'kshenoy/vim-signature'
    Plug 'haya14busa/incsearch.vim'
    Plug 'tomasr/molokai'
    Plug 'liuchengxu/space-vim-dark'
    Plug 'rhysd/vim-clang-format',           { 'for': [ 'c', 'cpp' ] }
    Plug 'octol/vim-cpp-enhanced-highlight', { 'for': [ 'c', 'cpp' ] }
    Plug 'romainl/vim-qf'
    if (g:os_gui && g:os_platform == 'windows')
        Plug 'Shougo/neocomplete.vim'
        Plug 'plasticboy/vim-markdown'
        Plug 'iamcco/mathjax-support-for-mkdp'
        Plug 'iamcco/markdown-preview.vim'
    endif

    call plug#end()
endif
" }}}

" Basic Setting {{{1
filetype plugin on
filetype indent on
syntax enable
syntax on
silent! color space-vim-dark
set  nocompatible
set    expandtab
set    shiftwidth=4
set    tabstop=4
set    softtabstop=4
set    smarttab
set    number
set    rnu
set    numberwidth=5
set  nowrap
set    autoindent
set    autoread
set    autowrite
set    background=dark
set  nobackup
set    backspace=indent,eol,start
set    cindent
set    cinoptions=:0
set    cinoptions+=g0
set    clipboard+=unnamedplus
set    cursorline
set    complete+=k
set    completeopt=menuone,longest,preview
set    encoding=utf-8
set    langmenu=none
set    termencoding=utf-8
set    fileencoding=utf-8
set    fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1,default
set    fileformats=unix,dos
set    foldenable
set    foldmethod=marker
set    guioptions-=Trml
set    helplang=en
set    hidden
set    history=100
set    hlsearch
set    ruler
set    showcmd
set    incsearch
set    wildmenu
set    wildmode=list:longest,full
set    shortmess+=mrwx
set    smartcase
set    ignorecase
set    magic
set    mouse=a
set    mousehide
set    laststatus=2
set    lazyredraw
set  noshowmatch
set    matchtime=0
set    pumheight=15
set    scrolloff=5
set    smartindent
set    cmdheight=1
set    textwidth=180
set    timeoutlen=250
set    updatetime=1000
set    whichwrap=h,l
set    wildignore=*.bak,*.o,*.e,*~
set    wildignore+=*/tmp/*,*.so,*.bin,*.swp,*.ctag
set  nowritebackup
set    sessionoptions=buffers,globals,localoptions,curdir,tabpages,winsize,winpos,resize
set  noswapfile
set    ignorecase

" }}}
" Basic Functions {{{1
let g:proj_dir     = ".projDir" " Used for manage current project
let g:session_file = "project.vim"
let g:viminfo_file = "viminfo.vim"
let g:ctags_cmd    = 'ctags -f tags -I __THROW -I __THROWNL -I __nonnull -R --c-kinds=+p --fields=+iaS --extra=+q'
let g:current_path = getcwd()
let g:proj_path    = g:current_path.'/'.g:proj_dir

" different log level print {{{2
function! Msg_Err(msg)
    echohl ErrorMsg
    echom '[error] '.a:msg
    echohl None
endfunction

function! Msg_Warn(msg)
    echom '[warning] '.a:msg
endfunction

function! Msg_Info(msg)
    echom '[info] '.a:msg
endfunction
" }}}

function! Sync_RunSysCmd(Msg, Cmd)
    call Msg_Info(a:Msg)
    call system(a:Cmd)
    echon 'done'
endfunction

function! Async_RunSysCmd(Msg, Cmd)
    call Msg_Info(a:Msg)
    let job = job_start(['/bin/bash', '-c', a:Cmd, { 'on_exit': call Msg_Info("done") })
endfunction

func! EnterHandler()
    if filereadable(g:proj_path.'/'.g:session_file) && (argc() == 0)
        exe "source ".g:proj_path.'/'.g:session_file
    endif
    if filereadable(g:proj_path.'/'.g:viminfo_file) && (argc() == 0)
        exe "rviminfo! ".g:proj_path.'/'.g:viminfo_file
    endif
endfunction

func! LeaveHandler()
    if isdirectory(g:proj_path)
        exec "mksession! ".g:proj_path."/".g:session_file
        exec "wviminfo! ".g:proj_path."/".g:viminfo_file
    endif
endfunction

" Replace in VIM Normal mode.
function! NormalReplace()
    let l:word = input("Replace<".expand('<cword>')."> with:")
    :exe '%s/\<'.expand('<cword>').'\>/'.l:word.'/gc'
endfunction
" Replace in VIM Visible mode.
function! VisualReplace()
    let l:saved_reg = @"
    execute "normal! vgvy"
    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")
    let l:word = input("Replace " . l:pattern . " with:")
    :exe '%s/' . l:pattern . '/' . l:word . '/gc'
    let @" = l:saved_reg
endfunction

" Used be as parenthesis complete, if "}",")","]" already exist, just to move right a character.
" Otherwise readly type it.
function! ClosePair(char)
    if getline('.')[col('.') - 1] == a:char
        return "\<Right>"
    else
        return a:char
    endif
endfunction

function! PasteToggle()
    set nu!
    set rnu!
    exe 'GitGutterSignsToggle'
    exe 'SignatureToggleSigns'
endfunction

" }}}
" Usful mapping {{{1
let mapleader=','
let localleader="\\"
nnoremap <Space>                :
vnoremap <Space>                :
inoremap jk                     <Esc>
vnoremap hl                     <Esc>
nnoremap <C-h>                  <C-W>h
nnoremap <C-j>                  <C-W>j
nnoremap <C-k>                  <C-W>k
nnoremap <C-l>                  <C-W>l
inoremap <C-h>                  <Esc><C-W>h
inoremap <C-j>                  <Esc><C-W>j
inoremap <C-k>                  <Esc><C-W>k
inoremap <C-l>                  <Esc><C-W>l
nnoremap <C-a>                  ggVG
inoremap <C-a>                  <C-O>gg<C-O>V<C-O>G
vnoremap <C-a>                  <C-C>ggVG
noremap  <C-S>                  :update<CR>
vnoremap <silent><C-S>                  <C-C>:update<CR>
inoremap <silent><C-S>                  <C-O>:update<CR>
nnoremap <C-Down>               ddp
nnoremap <C-Up>                 ddkP
nnoremap <Plug>(window_w) <C-W>w
nnoremap <Plug>(window_r) <C-W>r
nnoremap <Plug>(window_d) <C-W>c
nnoremap <Plug>(window_q) <C-W>q
nnoremap <Plug>(window_j) <C-W>j
nnoremap <Plug>(window_k) <C-W>k
nnoremap <Plug>(window_h) <C-W>h
nnoremap <Plug>(window_l) <C-W>l
nnoremap <Plug>(window_H) <C-W>5<
nnoremap <Plug>(window_L) <C-W>5>
nnoremap <Plug>(window_J) :resize +5<CR>
nnoremap <Plug>(window_K) :resize -5<CR>
nnoremap <Plug>(window_b) <C-W>=
nnoremap <Plug>(window_s1) <C-W>s
nnoremap <Plug>(window_s2) <C-W>s
nnoremap <Plug>(window_v1) <C-W>v
nnoremap <Plug>(window_v2) <C-W>v
nnoremap <Plug>(window_2) <C-W>v
if (g:os_platform == 'windows')
    inoremap <C-v>              <Esc>"+gP
    vnoremap <C-c>              "+y<Esc>
    cnoremap <C-v>              <C-R>+
    nnoremap <M-j>              :resize +5<cr>
    nnoremap <M-k>              :resize -5<cr>
    nnoremap <M-h>              :vertical resize -5<cr>
    nnoremap <M-l>              :vertical resize +5<cr>
endif
if (g:os_platform == 'Unix')
    vnoremap <leader>yy :w !pbcopy<CR>
    nnoremap <leader>pp :r !pbpaste<CR>
endif
nnoremap <silent>H              0
nnoremap <silent>L              $
nnoremap <Left>                 :bp<cr>
nnoremap <Right>                :bn<cr>
nnoremap <C-u>                  <Esc>ViwU<Esc>
inoremap <C-u>                  <Esc>ViwU<Esc>$a
nnoremap <Plug>Replace          :call NormalReplace()<cr>
vnoremap <Plug>Replace          :call VisualReplace()<cr>
nnoremap n                  nzz
nnoremap N                  Nzz
nnoremap G                  Gzz
nnoremap {                  {zz
nnoremap }                  }zz

vnoremap <                  <gv     " Indent  in vsual mode
vnoremap >                  >gv     " Deindent in visual mode shiftwidth

" New learnning.
nnoremap <leader>w" viw<Esc>i"<Esc>hbi"<Esc>lel
vnoremap <leader>w" iw<Esc>i"<Esc>h`<<Esc>i"<Esc>l`>l
onoremap p i(
onoremap in( :<C-u>normal! f(vi(<cr>
onoremap il( :<C-u>normal! F)vi(<cr>

" Get rid of my old mapping
inoremap <up>       <nop>
inoremap <down>     <nop>
inoremap <left>     <nop>
inoremap <right>    <nop>
nnoremap <up>       <nop>
nnoremap <down>     <nop>
noremap  <C-f>      <nop>       " <C-f> is the header of FZF
" }}}
" Autocmd for VIM events {{{1
" Restore the last position when reopen
" Specific identations
augroup identationGroup
    " Prevent duplicates on multiple .vimrc load
    autocmd!
    autocmd Filetype c              setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype cpp            setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype python         setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype php            setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype groovy         setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype javascript     setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype typescript     setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype json           setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype coffee         setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype pug            setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype sass           setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype scss           setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype styl           setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype css            setlocal nowrap tabstop=2 shiftwidth=2 softtabstop=2 expandtab
    autocmd Filetype dockerfile     setlocal nowrap tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    autocmd Filetype Makefile       setlocal nowrap tabstop=4 shiftwidth=4 noexpandtab
    autocmd Filetype *.txt          setlocal spell,wrap,nonu
    autocmd Filetype *.log          setlocal wrap
augroup END

augroup fileOperateGroup
    autocmd!
    autocmd InsertLeave *           if pumvisible() == 0|pclose|endif
    " Don't auto change line in blow files.
    autocmd BufReadPost *
                \ if line("'\"") > 0 && line("'\"") <= line("$") |
                \ exe "normal g'\"" |
                \ endif
    " autocmd BufEnter * silent! lcd %:p:h
    " autocmd VimLeave * silent! lcd g:current_path
augroup END

augroup projectConfigGroup
    autocmd!
    autocmd VimEnter * call EnterHandler()
    autocmd VimLeave * call LeaveHandler()
augroup END

augroup signAutoCompleteGroup
    " Prevent load multiple times
    autocmd!
    autocmd FileType c,cpp,jva,javascript,python,php,json,css
                \ inoremap ( ()<ESC>i|
                \ inoremap ) <c-r>=ClosePair(')')<CR>|
                \ inoremap { {}<ESC>i|
                \ inoremap } <c-r>=ClosePair('}')<CR>|
                \ inoremap [ []<ESC>i|
                \ inoremap ] <c-r>=ClosePair(']')<CR>|
                \ inoremap " ""<ESC>i|
                \ inoremap ' ''<ESC>i
augroup END

" }}}
" Abbreviations
iabbrev @@      lujunboo@gmail.com
iabbrev ccopy   Copyright 2018 JohnBro<cr>lujunboo@gmail.com
" Plugin Settings{{{1
" Ag setting {{{2
if executable('ag') && isdirectory(expand(g:dir_plugin.'/ag.vim/'))
    function! AgSymbolBuffer()
        let s:ag_symbol = input("Ag symbol in buffers:")
        :exe 'AgBuffer! '.s:ag_symbol
    endfunction

    let s:ag_ignores = '--ignore ".git/" --ignore ".hg/" --ignore ".svn/"'  " dirs
    let s:ag_ignores .= ' --ignore "*.so" --ignore "*.o"'                   " files
    let g:ag_arg = 'ag --vimgrep --smart-case --nocolumn --nogroup --skip-vcs-ignores '.s:ag_ignores
    let g:ag_highlight=1
    let g:ag_format="%f:%l:%m"
    let g:ag_qhandler="botright copen 12"
    let g:ag_autoclose=1
    let g:ag_working_path_mode='r'

    noremap <F5>        :AgBuffer! <C-R><C-W><CR>
endif
" }}}
" FZF setting {{{2
if isdirectory(expand(g:dir_plugin.'/fzf/')) && isdirectory(expand(g:dir_plugin.'/fzf.vim/'))
    let g:fzf_tags_command = g:ctags_cmd
    function! AgSymbolProj()
        let s:ag_symbol = input("Ag symbol in project:")
        :exe 'FAg '.s:ag_symbol
    endfunction

    command! -bang -nargs=* FAg
                \ call fzf#vim#ag(<q-args>,
                \                 <bang>0 ? fzf#vim#with_preview('up:60%')
                \                         : fzf#vim#with_preview('right:50%:hidden', '?'),
                \                 <bang>0)

    command! -bang -nargs=? -complete=dir Files
                \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)

    noremap  <F6>       :FAg! <C-R><C-W><CR>
    nnoremap <C-p>      :exec 'Files '.g:current_path<CR>              " Using this <C-p> to replace Ctrlp mapping
endif
" }}}
" Ctrlp.vim settings {{{2
if isdirectory(expand(g:dir_plugin.'/ctrlp.vim/'))
    nnoremap <F4>       :CtrlPMRU<cr>
    let g:loaded_ctrlp=0
    let g:ctrlp_working_path_mode='ra'
    let g:ctrlp_match_window='bottom,order:btt,min:1,max:12,results:12'
    let g:ctrlp_by_filename=1
    let g:ctrlp_switch_buffer = 'et'
    let g:ctrlp_regexp = 1
    let g:ctrlp_default_input=0
    let g:ctrlp_use_caching=1
    let g:ctrlp_clear_cache_on_exit=0
    let g:ctrlp_mruf_max = 250
    let g:ctrlp_max_history=&history
    let g:ctrlp_lazy_update=1
    let g:ctrlp_map = '<c-p>'
    let g:ctrlp_cmd = 'CtrlP'
    let g:ctrlp_follow_symlinks = 1
    let g:ctrlp_mruf_relative = 1
    let g:ctrlp_mruf_execlude = '/tmp/.*\|/temp/.*'
    let g:ctrlp_cache_dir=$HOME.'/.cache/ctrlp'
    let g:ctrlp_custom_ignore = {
                \ 'dir':  '\v[\/]\.(git|hg|svn)$',
                \ 'file': '\v(\.exe|\.so|\.dll|\.bin|\.pkg|\.bak|\.\~|\.mak|Makefile|\.zip|\.tar|\.gz|\.bz2)',
                \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
                \ }
    if executable('ag')
        " Use Ag over Grep
        set grepprg=ag\ --nogroup\ --nocolor
        " Use Ag in Ctrlp for listing files
        let s:ctrlp_fallback = 'ag %s -l -g ""'
        let g:ctrlp_use_caching = 0
    elseif executable('ack-grep')
        let s:ctrlp_fallback='ack-grep %s --nogroup -f ""'
        let g:ctrlp_use_caching = 0
    elseif executable('ack')
        let s:ctrlp_fallback='ack %s --nogroup -f ""'
        let g:ctrlp_use_caching = 0
    elseif has('win32')
        let s:ctrlp_fallback='dir %s /-n /b /s /a-d'
        let g:ctrlp_use_caching = 0
    else
        if (g:os_platform == 'windows')
            let s:ctrlp_fallback = 'dir %s /-n /b /s /a-d' " Windows
        else
            let s:ctrlp_fallback = 'find %s -type f'       " MacOSX/Linux
        endif
    endif
    if exists("g:ctrlp_user_command")
        unlet g:ctrlp_user_command
    endif
    if exists("s:ctrlp_fallback")
        let g:ctrlp_user_command = {
                    \ 'types': {
                    \ 1: ['.git', 'cd %s && git ls-files . --cached --others'],
                    \ 2: ['.hg', 'hg --cwd %s locate -I .'],
                    \ },
                    \ 'fallback': s:ctrlp_fallback
                    \ }
    endif
    " Fast CtrlP matcher based on python, performance difference is up to x22
    if isdirectory(expand("~/.vim/bundle/ctrlp-py-matcher/"))
        let g:ctrlp_match_func = {'match': 'pymatcher#PyMatch'}
    endif

    nmap <Plug>CtrlP_RecentFiles    :CtrlPMRU<cr>
    omap <Plug>CtrlP_RecentFiles    :CtrlPMRU<cr>
    vmap <Plug>CtrlP_RecentFiles    :CtrlPMRU<cr>
endif
" }}}
" Tagbar settings {{{2
if isdirectory(expand(g:dir_plugin.'/tagbar/')) && executable('ctags')
    nnoremap <F2> :TagbarToggle<cr>
    let g:tagbar_left=1
    let g:tagbar_width=30
    let g:tagbar_autoclose=1
    let g:tagbar_autofocus=1
    let g:tagbar_sort=0
    let g:tagbar_compact = 1
    let g:tagbar_indent = 1
    let g:tagbar_autopreview = 1
    let g:tagbar_foldlevel=2
    let g:tagbar_previewwin_pos="rightbelow"
endif
" }}}
" Nerdtree settings {{{2
if isdirectory(expand(g:dir_plugin.'/nerdtree/'))
    augroup loadNerdtree
        autocmd!
        autocmd VimEnter * silent! autocmd! FileExplorer
        autocmd BufEnter,BufNew *
                    \  if isdirectory(expand('<amatch>'))
                    \|   call plug#load('nerdtree')
                    \|   call nerdtree#checkForBrowse(expand("<amatch>"))
                    \| endif
    augroup END

    nnoremap <F3> :NERDTreeToggle<cr>
    let NERDTreeQuitOnOpen=1
    let NERDTreeShowLineNumbers=1
    let NERDTreeWinPos="right"
    let NERDTreeWinSize=30
    if isdirectory(expand("~/.vim/bundle/nerdtree-git-plugin"))
        let g:NERDTreeIndicatorMapCustom = {
                    \ "Modified"  : "✹",
                    \ "Staged"    : "✚",
                    \ "Untracked" : "✭",
                    \ "Renamed"   : "➜",
                    \ "Unmerged"  : "═",
                    \ "Deleted"   : "✖",
                    \ "Dirty"     : "✗",
                    \ "Clean"     : "✔︎",
                    \ 'Ignored'   : '☒',
                    \ "Unknown"   : "?"
                    \ }
    endif
endif
" }}}
" Syntastic settings {{{2
if isdirectory(expand(g:dir_plugin.'/syntastic/'))
    set    statusline+=%#warningmsg#
    set    statusline+=%{SyntasticStatuslineFlag()}
    set    statusline+=%*
    "let g:syntastic_always_populate_loc_list = 1
    "let g:syntastic_auto_loc_list = 1
    let g:syntastic_check_on_open = 1
    let g:syntastic_check_on_wq = 1
    let g:syntastic_error_symbol='>>'
    let g:syntastic_warning_symbol='>'
    let g:syntastic_enable_highlighting=1
    let g:syntastic_auto_jump=0
    "let g:syntastic_airline
    let g:syntastic_javascript_checkers = ['jsl', 'jshint']
    let g:syntastic_html_checkers=['tidy', 'jshint']

    let g:syntastic_c_check_header = 0
    let g:syntastic_c_remove_include_headers=1
    let g:syntastic_cpp_check_errors = 1
    let g:syntastic_cpp_remove_include_headers=0
    function! ToggleErrors()
        let old_last_winnr = winnr('$')
        lclose
        if old_last_winnr == winnr('$')
            " Nothing was closed, open syntastic error location panel
            Errors
        endif
    endfunction
    nnoremap <Leader>s :call ToggleErrors()<cr>
    nnoremap <Leader>sn :lnext<cr>
    nnoremap <Leader>sp :lprevious<cr>
endif
" }}}
" NERDcommenter settings {{{2
if isdirectory(expand(g:dir_plugin.'/nerdcommenter/'))
    let g:NERDSpaceDelims            = 1
    let g:NERDComaptSexyComs         = 1
    let g:NERDAltDelims_java         = 1
    let g:NERDCommentEmptyLines      = 1
    let g:NERDDefaultAlign           = 'left'
    let g:NERDTrimTrailingWhitespace = 1
    let NERDCreateDefaultMappings    = 0

    nmap <Leader>;; <Plug>NERDCommenterToggle
    omap <Leader>;; <Plug>NERDCommenterToggle
    vmap <Leader>;; <Plug>NERDCommenterToggle
    nmap <Leader>;c <Plug>NERDCommenterComment
    omap <Leader>;c <Plug>NERDCommenterComment
    vmap <Leader>;c <Plug>NERDCommenterComment
    nmap <Leader>;u <Plug>NERDCommenterUncomment
    omap <Leader>;u <Plug>NERDCommenterUncomment
    vmap <Leader>;u <Plug>NERDCommenterUncomment
endif
" }}}
" Completion Plugin configuration {{{2
" Common configuration {{{3
inoremap <expr> <CR>       pumvisible() ? "\<C-y>" : "\<CR>"
inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"
inoremap <expr> <PageDown> pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<PageDown>"
inoremap <expr> <PageUp>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<PageUp>"
"}}}
" YouCompleteMe settings {{{3
" !Windows : Completer by YouCompleteMe
" Step1, 编译安装llvm+clang, record 这个目录为 llvm_root_dir
" Step2, 编译 ycm_core.(指定不使用 python2, 防止冲突)
"   mkdir ycm_build; cd ycm_build;  ycm_build 为不在源码的任意目录.
"   cmake -G "<generator>" -DUSE_PYTHON2=OFF -DPATH_TO_LLVM_ROOT=~/ycm_temp/llvm_root_dir . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp
"   cmake --build . --target ycm_core --config Release
"   需要指定 python 二进制和 python 的搜索目录为 python3 的目录
if (isdirectory(expand(g:dir_plugin.'/YouCompleteMe/')))
    let g:ycm_global_ycm_extra_conf               = g:dir_plugin.'/YouCompleteMe/.ycm_extra_conf.py'
    let g:ycm_confirm_extra_conf                  = 0
    let g:ycm_show_diagnostics_ui                 = 1
    let g:ycm_server_log_level                    = 'info'
    let g:ycm_collect_identifiers_from_tags_files = 1
    let g:ycm_min_num_of_chars_for_completion     = 2
    let g:ycm_min_num_identifier_candidate_chars  = 2
    let g:ycm_seed_identifiers_with_syntax        = 1 " Open syntax complete
    let g:ycm_complete_in_comments                = 1 " Also in comments
    let g:ycm_complete_in_strings                 = 1
    let g:ycm_cache_omnifunc                      = 0
    let g:ycm_add_preview_to_completeopt          = 0
    let g:ycm_key_invoke_completion               = '<C-z>'
    let g:ycm_python_binary_path                  = '/usr/bin/python3'
    let g:ycm_server_python_interpreter           = '/usr/bin/python3'
    let g:ycm_semantic_triggers                   = {
                \   'c' : ['->', '.', 're!\w{3}'],
                \   'objc' : ['->', '.', 're!\[[_a-zA-Z]+\w*\s', 're!^\s*[^\W\d]\w*\s',
                \             're!\[.*\]\s'],
                \   'ocaml' : ['.', '#'],
                \   'cpp,cuda,objcpp' : ['->', '.', '::', 're!\w{3}'],
                \   'perl' : ['->'],
                \   'php' : ['->', '::'],
                \   'cs,java,javascript,typescript,d,python,perl6,scala,vb,elixir,go' : ['.'],
                \   'ruby' : ['.', '::'],
                \   'lua' : ['.', ':'],
                \   'erlang' : [':'],
                \ }
    let g:ycm_filetype_blacklist                  = {
                \ 'tagbar' : 1,
                \ 'nerdtree' : 1,
                \ 'markdown' : 1,
                \ 'unite' : 1,
                \ 'text' : 1,
                \ 'vimwiki' : 1,
                \ 'pandoc' : 1,
                \ 'infolog' : 1,
                \ 'mail' : 1
                \ }
    let g:ycm_key_detailed_diagnostics            = ""

    augroup spacevimYcm
        autocmd!
        " Enable omni completion.
        autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
        autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
        autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
        autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
        autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
        autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
        autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

        " Key bindings
        autocmd FileType c,cpp,python,go,javascript,rust
                    \   nnoremap <LocalLeader>gd :YcmCompleter GoTo<CR>
        autocmd FileType c,cpp,python,rust,javascript,typescript
                    \   nnoremap <LocalLeader>gD :YcmCompleter GetDoc<CR>
        autocmd FileType c,cpp
                    \   nnoremap <LocalLeader>gi :YcmCompleter GoToInclude<CR>
        autocmd FileType javascript,python,typescript
                    \   nnoremap <LocalLeader>gr :YcmCompleter GoToReferences<CR>
        autocmd FileType c,cpp,javascript,typescript
                    \   nnoremap <LocalLeader>gt :YcmCompleter GetType<CR>
        autocmd FileType c,cpp
                    \   nnoremap <LocalLeader>gp :YcmCompleter GetParent<CR>
    augroup END
endif
" }}}
" }}}
" vim Markdown setting, just in gui {{{2
if isdirectory(expand(g:dir_plugin.'/markdown-preview.vim/'))
    let g:mkdp_path_to_chrome = "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"
    let g:mkdp_auto_start = 0
    let g:mkdp_auto_open = 0
    let g:mkdp_auto_close = 1
    let g:mkdp_refresh_slow = 0
    let g:mkdp_command_for_global = 0
    nnoremap <silent> <F11> <Plug>MarkdownPreview
    inoremap <silent> <F11> <Plug>MarkdownPreview
    nnoremap <leader>ms <Plug>StopMarkdownPreview
endif
"}}}
" VIM Multiple Line setting {{{2
if isdirectory(expand(g:dir_plugin.'/vim-multiple-cursors/'))
    " Default mapping
    let g:multi_cursor_use_default_mapping = 0
    let g:multi_cursor_start_word_key      = '<C-n>'
    let g:multi_cursor_select_all_word_key = '<A-n>'
    let g:multi_cursor_start_key           = 'g<C-n>'
    let g:multi_cursor_select_all_key      = 'g<A-n>'
    let g:multi_cursor_next_key            = '<C-n>'
    let g:multi_cursor_prev_key            = '<C-p>'
    let g:multi_cursor_skip_key            = '<C-x>'
    let g:multi_cursor_quit_key            = '<Esc>'
endif
"}}}
" Better white-space setting {{{2
if isdirectory(expand(g:dir_plugin.'/vim-better-whitespace/'))
    hi ExtraWhitespace guifg=#FF2626 gui=underline ctermfg=124 cterm=underline
    match ExtraWhitespace /\s\+$/
    let g:better_whitespace_filetypes_blacklist=['txt', 'log', 'diff', 'unite', 'qf', 'help']
    let g:better_whitespace_verbosity = 0
    let g:better_whitespace_oprator = '<localleader>wt'
    autocmd     FileType    javascript,c,cpp,java,html,ruby,vimscript,shell
                \ autocmd BufEnter <buffer>     EnableWhitespace
endif
"}}}
" Ctags setting {{{2
if isdirectory(expand(g:dir_plugin.'/vim-gutentags/')) && executable('ctags')
    let g:ctags_file = 'tags'
    let g:ctags_path = g:current_path

    function! GenerateCtags()
        if filereadable(g:ctags_path.'/'.g:ctags_file)
            let l:ctags_force_gen = input("Ctags file already exist, replace it ?[y/N]")
            if (l:ctags_force_gen == 'y' || l:ctags_force_gen == 'Y')
                echo "\n"
                call Sync_RunSysCmd('Start to generate Ctags...', g:ctags_cmd)
            endif
        else
            call Sync_RunSysCmd('Start to generate Ctags...', g:ctags_cmd)
        endif
        setglobal tags+=tags
        if !isdirectory(g:proj_path)
            call Sync_RunSysCmd('Create project directory...', 'mkdir '.g:proj_path)
        endif
    endfunction

    let g:gutentags_ctags_tagfile          = g:ctags_file
    let g:gutentags_ctags_extra_args       = ['--fields=+niazS', '--extra=+q']
    let g:gutentags_ctags_extra_args      += ['--c++-kinds=+px']
    let g:gutentags_ctags_extra_args      += ['--c-kinds=+px']
    let g:gutentags_auto_add_gtags_cscope  = 0
    let g:gutentags_cache_dir              = ''

    autocmd BufReadPre *.c,*.h,*.cpp,*.cxx  set tags+=tags;,tags;
    nnoremap <F9>        : call GenerateCtags()<cr>
endif
" }}}
" Cscope setting {{{2
if has('cscope') && executable('cscope')
    " cscope databases are searched first, followed by tag files if cscope did not return any matches.
    set csto=0
    " always search cscope database as well as tag files.
    set cscopetag
    set cscopequickfix=s+,c+,d+,i+,t+,e+,a+
    " Show message when any oterhs cscope db added
    " set cscopeverbose
    let g:cscope_file = 'cscope.out'
    let g:cscope_path = g:proj_path
    let g:cscope_cmd  = 'cscope -Rbq -f '.g:cscope_path.'/'.g:cscope_file
    let g:cscope_is_building = 0

    " Use s:add_db for both async callback and sync mode {{{3
    function! s:add_db(channel)
        " add any database in current directory
        let db    = findfile('cscope.out', g:cscope_path.';')
        let l:cmd = g:cscope_cmd
        " :h cscope-suggestions
        set nocsverb
        if !empty(db)
            " FIXME: when building cscope using job api at the first time, cscope.in.out won't be generated.
            " Thus it raises errors when running `cs add`, use try-catch to rebuild cscope.
            try
                silent cs reset
                silent! execute 'cs add' db
            catch
                call s:build_async(l:cmd)
            endtry
            " else add database pointed to by environment
        elseif !empty($CSCOPE_DB)
            silent cs reset
            silent! execute 'cs add' $CSCOPE_DB
        else
            call s:build_async(l:cmd)
        endif
        set csverb
        let g:cscope_is_building = 0
        echo "\r\r"
    endfunction
    " }}}
    " cscope build sync&async function {{{3
    function! s:build_sync(...)
        for cmd in a:000
            call system(cmd)
        endfor
        call s:add_db('')
    endfunction

    function! s:on_exit_cb(job_id, data, event) dict
        call s:add_db('')
    endfunction

    function! s:build_async(cmd)
        let job = job_start(['bash', '-c', a:cmd], { 'close_cb': function('s:add_db') })
    endfunction

    function! s:build()
        let g:cscope_is_building = 1
        let root_dir = g:cscope_path
        let exts = empty(a:000) ?
                    \ ['java', 'c', 'h', 'cc', 'hh', 'cpp', 'hpp'] : a:000
        let tmp   = g:cscope_file
        let l:cmd = g:cscope_cmd
        try
            if exists('*job_start') || exists('*jobstart')
                call s:build_async(l:cmd)
            else
                call s:build_sync(l:cmd)
            endif
        finally
            silent! call delete(tmp)
        endtry
    endfunction
    "}}}
    " cscope find static function {{{3
    function! s:find(type)
        let l:opt = {
                    \ 'symbol':'s', 'global': 'g', 'calls': 'c', 'text': 't', 'egrep': 'e', 'called':'d',
                    \ }
        let l:cword = expand("<cword>")
        for [l:key, l:value] in items(l:opt)
            if l:key == a:type
                try
                    exe ":cs find ".l:value." ".l:cword
                    return
                catch /^Vim\%((\a\+)\)\=:E259/
                    call Msg_Err('cscope trys finding <'.l:key.'>, but no matches for '.l:cword)
                endtry
            endif
        endfor
        if a:type == 'file'
            :cs find f <cfile>
        elseif a:type == 'includes'
            :cs find i <cfile>
        endif
    endfunction
    " }}}
    " Cscope external interface {{{3
    function! Cscope_Build()
        if !isdirectory(g:cscope_path)
            call Sync_RunSysCmd('Create project directory...', 'mkdir '.g:cscope_path)
        endif
        if filereadable(g:cscope_path.'/'.g:cscope_file)
            call Msg_Info("Cscope file already exist!")
            exe 'cscope add '.g:cscope_path.'/'.g:cscope_file
        elseif $CSCOPE_DB != ""
            cscope add $CSCOPE_DB
        else
            " Support async feature
            if exists('*job_start') || exists('*jobstart')
                call s:build()
            else
                call Sync_RunSysCmd('Generate cscope...', g:cscope_cmd)
                exe 'cscope add '.g:cscope_path.'/'.g:cscope_file
            endif
        endif
    endfunction

    function! Cscope_Update()
        if filereadable(g:cscope_path.'/'.g:cscope_file)
            call s:build()
        endif
    endfunction

    function! Cscope_Find(type)
        if g:cscope_is_building
            call Msg_Info('still building the cscope database, please wait for seconds...')
            return
        endif
        try
            call s:find(a:type)
        catch /E567: no cscope connections/
            if filereadable(g:cscope_path.'/'.g:cscope_file)
                exe 'cscope add '.g:cscope_path.'/'.g:cscope_file
            elseif $CSCOPE_DB != ""
                cscope add $CSCOPE_DB
            else
                call Cscope_Build()
            endif
        endtry
    endfunction
    " }}}

    augroup signAutoCompleteGroup
        " Prevent load multiple times
        autocmd!
        autocmd BufReadPre *.c,*.cpp,*.h,*.cxx
                    \ if filereadable(g:cscope_path.'/'.g:cscope_file) |
                    \     exe 'cscope add '.g:cscope_path.'/'.g:cscope_file |
                    \ elseif $CSCOPE_DB != "" |
                    \     cscope add $CSCOPE_DB |
                    \ endif

        autocmd BufWritePost *.c,*.cpp,*.h,*.cxx
                    \ if isdirectory(g:cscope_path) |
                    \     call Cscope_Update()      |
                    \ endif
    augroup END

    " <F10> To establish a cscope enviroment.
    nmap <F10>              :call Cscope_Build()<cr>
    nmap <Plug>Cscope_Add   :exec 'cscope add '.g:cscope_path.'/'.g:cscope_file<cr>

    nnoremap <leader>cs :call Cscope_Find('symbol')<CR>
    nnoremap <leader>cg :call Cscope_Find('global')<CR>
    nnoremap <leader>cc :call Cscope_Find('calls')<CR>
    nnoremap <leader>ct :call Cscope_Find('text')<CR>
    nnoremap <leader>ce :call Cscope_Find('egrep')<CR>
    nnoremap <leader>cf :call Cscope_Find('file')<CR>
    nnoremap <leader>ci :call Cscope_Find('includes')<CR>
    nnoremap <leader>cd :call Cscope_Find('called')<CR>
endif
"}}}
" Vim-Gitgutter setting {{{2
if isdirectory(expand(g:dir_plugin.'/vim-gitgutter/'))
    let g:gitgutter_map_keys = 0
    let g:gitgutter_highlight_lines = 0
    let g:gitgutter_max_signs = 5000
    nmap [h <Plug>GitGutterPrevHunk
    nmap ]h <Plug>GitGutterNextHunk
endif
" }}}
" DoxygenToolkit.vim setting {{{2
if isdirectory(expand(g:dir_plugin.'/DoxygenToolkit.vim/'))
    let g:doxygen_enhanced_color           = 1
    let g:DoxygenToolkit_commentType       = "C"
    let g:DoxygenToolkit_briefTag_funcName = "yes"
    let g:DoxygenToolkit_dataTag           = "@data    "
    let g:DoxygenToolkit_briefTag_pre      = "@fn      "
    let g:DoxygenToolkit_briefTag_post     = "@brief   "
    let g:DoxygenToolkit_paramTag_pre      = "@param[] "
    let g:DoxygenToolkit_returnTag         = "@retval  "
    let g:DoxygenToolkit_versionTag        = "@version "
    let g:DoxygenToolkit_authorName        = "JohnBro lujunboo@gmail.com"
    let g:DoxygenToolkit_blockHeader       = "--------------------------------------------------------------------------"
    let g:DoxygenToolkit_blockFooter       = "--------------------------------------------------------------------------"
endif
" }}}
" Tabularize & EasyAlign setting {{{2
if isdirectory(expand(g:dir_plugin.'/tabular/')) && isdirectory(expand(g:dir_plugin.'/vim-easy-align/'))
    nnoremap <Plug>(AlignWith&)     :Tabularize /&<CR>
    vnoremap <Plug>(AlignWith&)     :Tabularize /&<CR>
    nnoremap <Plug>(AlignWith=)     :Tabularize /^[^=]*\zs=<CR>
    vnoremap <Plug>(AlignWith=)     :Tabularize /^[^=]*\zs=<CR>
    nnoremap <Plug>(AlignWith=>)    :Tabularize /=><CR>
    vnoremap <Plug>(AlignWith=>)    :Tabularize /=><CR>
    nnoremap <Plug>(AlignWith:)     :Tabularize /:<CR>
    vnoremap <Plug>(AlignWith:)     :Tabularize /:<CR>
    nnoremap <Plug>(AlignWith::)    :Tabularize /:\zs<CR>
    vnoremap <Plug>(AlignWith::)    :Tabularize /:\zs<CR>
    nnoremap <Plug>(AlignWith,)     :Tabularize /,<CR>
    vnoremap <Plug>(AlignWith,)     :Tabularize /,<CR>
    nnoremap <Plug>(AlignWith,,)    :Tabularize /,\zs<CR>
    vnoremap <Plug>(AlignWith,,)    :Tabularize /,\zs<CR>
    nnoremap <Plug>(AlignWith<Bar>) :Tabularize /<Bar><CR>
    vnoremap <Plug>(AlignWith<Bar>) :Tabularize /<Bar><CR>

    " Start interactive EasyAlign in visual mode (e.g. vipxa)
    xmap <Plug>(AlignWith?) <Plug>(EasyAlign)
    " Start interactive EasyAlign for a motion/text object (e.g. xaip)
    nmap <Plug>(AlignWith?) <Plug>(EasyAlign)<cr>
endif
"}}}
" vim-fugitive setting {{{2
if isdirectory(expand(g:dir_plugin.'/vim-fugitive/'))
endif
" vim-signature setting {{{2
if isdirectory(expand(g:dir_plugin.'/vim-signature/'))
    let g:SignatureMap = {
                \ 'Leader'             :  "M",
                \ 'PlaceNextMark'      :  "M,",
                \ 'ToggleMarkAtLine'   :  "M.",
                \ 'PurgeMarksAtLine'   :  "M-",
                \ 'DeleteMark'         :  "MM",
                \ 'PurgeMarks'         :  "M<Space>",
                \ 'PurgeMarkers'       :  "M<BS>",
                \ 'GotoNextLineAlpha'  :  "']",
                \ 'GotoPrevLineAlpha'  :  "'[",
                \ 'GotoNextSpotAlpha'  :  "`]",
                \ 'GotoPrevSpotAlpha'  :  "`[",
                \ 'GotoNextLineByPos'  :  "]'",
                \ 'GotoPrevLineByPos'  :  "['",
                \ 'GotoNextSpotByPos'  :  "]`",
                \ 'GotoPrevSpotByPos'  :  "[`",
                \ 'GotoNextMarker'     :  "]-",
                \ 'GotoPrevMarker'     :  "[-",
                \ 'GotoNextMarkerAny'  :  "]=",
                \ 'GotoPrevMarkerAny'  :  "[=",
                \ 'ListBufferMarks'    :  "M/",
                \ 'ListBufferMarkers'  :  "M?"
                \ }
endif
" }}}
" Dictionary setting {{{2
if isdirectory(expand(g:dir_plugin.'/dictionary.vim/'))
    set thesaurus+=~/.vim/bundle/dictionary.vim/oald_cn.dict        " For <C-x><C-t> to preview
    set dictionary-=~/.vimrc
    set dictionary+=~/.vim/bundle/dictionary.vim/oald_cn.dict       " For <C-x><C-k> to preview
endif
" }}}
" c-c++ setting {{{2
let g:cpp_class_scope_highlight = 1
let g:c_no_curly_error=1
" }}}
" vim-leader-guide(<leader>) setting {{{2
if isdirectory(expand(g:dir_plugin.'/vim-leader-guide/'))
    let g:mapleader_map =  {}
    for s:i in range(1, 9)
        let g:mapleader_map[s:i] = [ s:i.'wincmd w', 'window '.s:i ]
    endfor

    let g:gutentags_project_root = [ g:proj_dir ]
    let g:mapleader_map[','] = [ 'normal "\<Esc>"','exit' ]
    let g:mapleader_map['?'] = [ 'Maps', 'show-keybindings' ]
    let g:mapleader_map[';'] = {
                \ 'name' : '+commenter',
                \ ';' : [ 'call feedkeys("\<Plug>NERDCommenterToggle")', 'comment-toggle' ],
                \ 'c' : [ 'call feedkeys("\<Plug>NERDCommenterComment")', 'comment-lines' ],
                \ 'u' : [ 'call feedkeys("\<Plug>NERDCommenterUncomment")', 'uncomment-lines' ],
                \ }
    let g:mapleader_map['='] = [ 'gg=G<C-O><C-O>:w', 'format-whole-file' ]
    let g:mapleader_map[' '] = [ 'call feedkeys("\<Space>")', 'cmd-line' ]
    " a leader mapping {{{3
    let g:mapleader_map['a'] = {
                \ 'name' : '+align',
                \ '&' : [ 'call feedkeys("\<Plug>(AlignWith&)")', 'align with &' ],
                \ '=' : [ 'call feedkeys("\<Plug>(AlignWith=)")', 'align with =' ],
                \ '=>' : [ 'call feedkeys("\<Plug>(AlignWith=>)")', 'align with =>' ],
                \ ':' : [ 'call feedkeys("\<Plug>(AlignWith:)")', 'align with :' ],
                \ '::' : [ 'call feedkeys("\<Plug>(AlignWith::)")', 'align with ::' ],
                \ ',' : [ 'call feedkeys("\<Plug>(AlignWith,)")', 'align with ,' ],
                \ ',,' : [ 'call feedkeys("\<Plug>(AlignWith,,)")', 'align with ,,' ],
                \ '|' : [ 'call feedkeys("\<Plug>(AlignWith<Bar>)")', 'align with |' ],
                \ 'w' : [ 'call feedkeys("\<Plug>(AlignWith?)")', 'align with what ?' ],
                \ 'g' : [ 'call AgSymbolBuffer()', 'ag symbol in buffer' ],
                \ 'G' : [ 'call AgSymbolProj()', 'ag symbol in project' ],
                \ }
    " }}}
    " b leader mapping {{{3
    let g:mapleader_map['b'] = {
                \ 'name' : '+buffer',
                \ '1' : ['b1', 'buffer 1'],
                \ '2' : ['b2', 'buffer 2'],
                \ '3' : ['b3', 'buffer 3'],
                \ '4' : ['b4', 'buffer 4'],
                \ '5' : ['b5', 'buffer 5'],
                \ '6' : ['b6', 'buffer 6'],
                \ '7' : ['b7', 'buffer 7'],
                \ '8' : ['b8', 'buffer 8'],
                \ '9' : ['b9', 'buffer 9'],
                \ 'b' : ['Buffers', 'fzf-buffer-list'],
                \ 'd' : ['bd', 'delete-buffer'],
                \ 'f' : ['bfirst', 'first-buffer'],
                \ 'h' : ['Startify', 'home-buffer'],
                \ 'k' : ['bw', 'kill-buffer'],
                \ 'l' : ['blast', 'last-buffer'],
                \ 'n' : ['bnext', 'next-buffer'],
                \ 'p' : ['bprevious', 'previous-buffer'],
                \ '?' : ['Buffers', 'fzf-buffer-list'],
                \ }
    " }}}
    " c leader mapping {{{3
    "   's'   symbol:   find all references to the token under cursor
    "   'g'   global:   find global definition(s) of the token under cursor
    "   'c'   calls:    find all calls to the function name under cursor
    "   't'   text:     find all instances of the text under cursor
    "   'e'   egrep:    egrep search for the word under cursor
    "   'f'   file:     open the filename under cursor
    "   'i'   includes: find files that include the filename under cursor
    "   'd'   called:   find functions that function under cursor calls
    let g:mapleader_map['c'] = {
                \ 'name' : '+cscope',
                \ 'a' : [ 'call feedkeys("\<Plug>Cscope_Add")', 'cscope-add-database' ],
                \ 'b' : [ 'call Cscope_Build()', 'cscope-build' ],
                \ 'u' : [ 'call Cscope_Update()', 'cscope-update' ],
                \ 's' : [ 'call Cscope_Find("symbol")', 'find-global-definition' ],
                \ 'g' : [ 'call Cscope_Find("global")', 'find-global-definition' ],
                \ 'c' : [ 'call Cscope_Find("calls")', 'find-all-calls' ],
                \ 't' : [ 'call Cscope_Find("text")', 'find-all-instance' ],
                \ 'e' : [ 'call Cscope_Find("egrep")', 'text-egrep-search' ],
                \ 'f' : [ 'call Cscope_Find("file")', 'open-the-filename' ],
                \ 'i' : [ 'call Cscope_Find("includes")', 'find-files-included' ],
                \ 'd' : [ 'call Cscope_Find("called")', 'find-all-functions' ],
                \ }
    " }}}
    " d leader mapping {{{3
    let g:mapleader_map['d'] = {
                \ 'name' : '+doxygen',
                \ 'a' : [ 'DoxAuthor', 'Doxygen autor-announce' ],
                \ 'b' : [ 'DoxBlock', 'Doxygen a-block-line' ],
                \ 'f' : [ 'Dox', 'Doxygen a-function' ],
                \ 'l' : [ 'DoxLic', 'Doxygen a-license' ],
                \ }
    " }}}
    " e leader mapping {{{3
    let g:mapleader_map['e'] = {
                \ 'name' : '+errors',
                \ 'n' : ['call feedkeys("\<Plug>(ale_next)")', 'next-error'],
                \ 'p' : ['call feedkeys("\<Plug>(ale_previous)")', 'previous-error'],
                \ 'v' : [ 'vsplit $MYVIMRC', 'edit local-vimrc'],
                \ }
    " }}}
    " f leader mapping {{{3
    let g:mapleader_map['f'] = {
                \ 'name' : '+find/files/fold',
                \ '0' : [ 'set foldlevel=0', '0-fold-level' ],
                \ '1' : [ 'set foldlevel=1', '1-fold-level' ],
                \ '2' : [ 'set foldlevel=2', '2-fold-level' ],
                \ '3' : [ 'set foldlevel=3', '3-fold-level' ],
                \ '4' : [ 'set foldlevel=4', '4-fold-level' ],
                \ '5' : [ 'set foldlevel=5', '5-fold-level' ],
                \ '6' : [ 'set foldlevel=6', '6-fold-level' ],
                \ '7' : [ 'set foldlevel=7', '7-fold-level' ],
                \ '8' : [ 'set foldlevel=8', '8-fold-level' ],
                \ '9' : [ 'set foldlevel=9', '9-fold-level' ],
                \ 'b' : [ 'BLines', 'fzf-find-current-buffer' ],
                \ 'c' : [ 'Commands', 'fzf-find-command' ],
                \ 'd' : [ 'NERDTreeFind', 'find-current-buffer-in-NERDTree' ],
                \ 'f' : [ 'Files '.g:current_path, 'files-in-project-direcotry' ],
                \ 'h' : [ 'Files ~', 'files-in-home-direcotry' ],
                \ 'm' : [ 'Marks', 'fzf-find-marks' ], 
                \ 'n' : [ 'let @"=substitute(expand("%"), "/", "\\", "g")', "file-name-copy" ],
                \ 'p' : [ 'let @"=substitute(expand("%:p"), "/", "\\", "g")', "file-path-copy" ],
                \ 'r' : [ 'call feedkeys("\<Plug>CtrlP_RecentFiles")', 'ctrlp-recent-files' ],
                \ 's' : [ 'save', 'save-file' ],
                \ 't' : [ 'Filetypes', 'fzf-find-file-type' ],
                \ '/' : [ 'Files', 'files-in-current-direcotry' ],
                \ 'R' : [ 'source $MYVIMRC', 'reload-vimrc' ],
                \ }
    " }}}
    " g leader mapping {{{3
    let g:mapleader_map['g'] = {
                \ 'name' : '+git/version-control',
                \ 'b' : ['Gblame', 'fugitive-blame'],
                \ 'c' : ['Gcommit', 'fugitive-commit'],
                \ 'd' : ['Gdiff', 'fugitive-diff'],
                \ 'e' : ['Gedit', 'fugitive-edit'],
                \ 'l' : ['Glog', 'fugitive-log'],
                \ 'r' : ['Gread', 'fugitive-read'],
                \ 's' : ['Gstatus', 'fugitive-status'],
                \ 'w' : ['Gwrite', 'fugitive-write'],
                \ 'p' : ['Git push', 'fugitive-push'],
                \ }
    " }}}
    " h leader mapping {{{3
    let g:mapleader_map['h'] = {
                \ 'name' : '+help/history',
                \ 'c' : [ 'History:', 'command history' ],
                \ 'f' : [ 'History', 'file history' ],
                \ 's' : [ 'History/', 'search history' ],
                \ }
    " }}}
    " j leader mapping {{{3
    let g:mapleader_map['j'] = {
                \ 'name' : '+jump',
                \ 'f' : [ 'BTags', 'jump-to-tags-in-buffer' ],
                \ 'g' : [ 'Tags', 'jump-to-tags-in-project' ],
                \ }
    " }}}
    " m leader mapping {{{3
    let g:mapleader_map['m'] = {
                \ 'name' : '+mark',
                \ 'r' : [ 'call feedkeys("\<Plug>MarkRegex")', 'mark regex' ],
                \ 's' : [ 'call feedkeys("\<Plug>MarkSet")', 'mark set' ],
                \ 'c' : [ 'call feedkeys("\<Plug>MarkClear")', 'mark clear' ],
                \ }
    " }}}
    " p leader mapping {{{3
    let g:mapleader_map['p'] = {
                \ 'name' : '+projects',
                \ 't' : [ 'call GenerateCtags()', 'generate-ctag-file' ],
                \ }
    " }}}
    " r leader mapping {{{3
    let g:mapleader_map['r'] = {
                \ 'name' : '+replace',
                \ 'w' : [ 'call feedkeys("\<Plug>Replace")', 'replace-selection' ],
                \ }
    " }}}
    " s leader mapping {{{3
    let g:mapleader_map['s'] = {
                \ 'name' : '+search/source',
                \ 'v' : [ 'source $MYVIMRC', 'reload local vimrc'],
                \ }
    " }}}
    " t leader mapping {{{3
    let g:mapleader_map['t'] = {
                \ 'name' : '+toggle',
                \ 'f' : [ 'NERDTreeToggle', 'toggle nerdtree-file-manager' ],
                \ 'g' : [ 'GitGutterSignsToggle', 'toggle git-diff-signs' ],
                \ 'G' : [ 'GitGutterLineHighlightsToggle', 'toggle git-diff-highlight' ],
                \ 'P' : [ 'call PasteToggle()', 'toggle paste' ],
                \ 's' : [ 'SignatureToggleSigns', 'toggle left-sign-mark' ],
                \ 'w' : [ 'ToggleStripWhitespaceOnSave', 'toggle remove whitespace' ],
                \ }
    let g:mapleader_map['T'] = {
                \ 'name' : '+Tab-ops',
                \ 'a' : [ 'tabnew', 'Tab add' ],
                \ 'c' : [ 'tabclose', 'Tab close' ],
                \ 'l' : [ 'tabs', 'Tab list' ],
                \ 'n' : [ 'tabnext', 'Tab next' ],
                \ 'p' : [ 'tabprevious', 'Tab previous' ],
                \ }
    " }}}
    " v leader mapping {{{3
    let g:mapleader_map['v'] = {
                \ 'name' : '+vim/visual',
                \ }
    " }}}
    " w leader mapping {{{3
    let g:mapleader_map['w'] = {
                \ 'name' : '+windows',
                \ 'w' : ['call feedkeys("\<Plug>(window_w)")', 'other-window'],
                \ 'd' : ['call feedkeys("\<Plug>(window_d)")', 'delete-window'],
                \ '-' : ['call feedkeys("\<Plug>(window_s1)")', 'split-window-below'],
                \ '|' : ['call feedkeys("\<Plug>(window_v1)")', 'split-window-right'],
                \ '2' : ['call feedkeys("\<Plug>(window_v1)")', 'layout-double-columns'],
                \ 'h' : ['call feedkeys("\<Plug>(window_h)")', 'window-left'],
                \ 'j' : ['call feedkeys("\<Plug>(window_j)")', 'window-below'],
                \ 'l' : ['call feedkeys("\<Plug>(window_l)")', 'window-right'],
                \ 'k' : ['call feedkeys("\<Plug>(window_k)")', 'window-up'],
                \ 'H' : ['call feedkeys("\<Plug>(window_H)")', 'expand-window-left'],
                \ 'J' : ['call feedkeys("\<Plug>(window_J)")', 'expand-window-below'],
                \ 'L' : ['call feedkeys("\<Plug>(window_L)")', 'expand-window-right'],
                \ 'K' : ['call feedkeys("\<Plug>(window_K)")', 'expand-window-up'],
                \ '=' : ['call feedkeys("\<Plug>(window_b)")', 'balance-window'],
                \ 's' : ['call feedkeys("\<Plug>(window_s1)")', 'split-window-horizontal'],
                \ 'v' : ['call feedkeys("\<Plug>(window_v1)")', 'split-window-vertical'],
                \ '?' : ['Windows', 'fzf-window'],
                \ }
    " }}}
    " x leader mapping {{{3
    let g:mapleader_map['x'] = {
                \ 'name' : '+text',
                \ 'a' : ['call feedkeys("\<Plug>(AlignWith?)")', 'easy-align'],
                \ 'd' : ['StripWhitespace', 'delete-trailing-whitespace'],
                \ 's' : ['SignatureListBufferMarks', 'list-buffer-mark-signs' ],
                \ }
    " }}}
    " y leader mapping {{{3
    let g:mapleader_map['y'] = {
                \ 'name' : '+ycm',
                \ 'c' : [ 'YcmCompleter GoToDeclaration', 'go-to-deClaration' ],
                \ 'e' : [ 'YcmDiags', 'errors-diags' ],
                \ 'f' : [ 'YcmCompleter GoToDefinition', 'go-to-function-Definition' ],
                \ 'u' : [ 'YcmCompleter GoToDefinitionElseDeclaration', 'go-to-definition-else-declaration' ],
                \ }
    " }}}
    call leaderGuide#register_prefix_descriptions(mapleader, "g:mapleader_map")

    nnoremap <silent> <leader> :<c-u>LeaderGuide mapleader<CR>
    vnoremap <silent> <leader> :<c-u>LeaderGuideVisual mapleader<CR>

    let g:localleader_map = {}
    call leaderGuide#register_prefix_descriptions(localleader, "g:localleader_map")
    nnoremap <silent> <localleader> :<c-u>LeaderGuide localleader<CR>
    vnoremap <silent> <localleader> :<c-u>LeaderGuideVisual localeader<CR>

    let g:markleader_map = {}
    call leaderGuide#register_prefix_descriptions("M", "g:markleader_map")
    nnoremap <silent> M :<c-u>LeaderGuide 'M'<CR>
    vnoremap <silent> M :<c-u>LeaderGuideVisual 'M'<CR>
endif
" }}}
" }}}
